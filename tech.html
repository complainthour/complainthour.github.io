<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>hi there</title>

</head>

<body>
  <h1> Tech </h1>


 <h3> <b> 1 Aug 2020 </b> Checking in on my 2020 goals </h3>
<p> Wow, it has been a while! As the COVID-19 pandemic completely took over life as we knew it in 2020, I was making sporadic progress on the goals I outlined above. I also have some more clarity on what I'm wanting looking into the future career-wise. So without further adieu, here's what I've been working on: </p>


  <ul>
    <li> <b> Configuration management (probably Ansible): </b> Nothing amazing here. </li>
    <li> <b> Containers: </b> I did put some time into this one! I got Docker Desktop set up at home and just poked around for a bit with the Flask image and said "hello, world!" from Docker. I also tried out a security product that's distributed as a Docker image. I took a self-paced course on containers and I generally understand the basics now. I know why you'd use one over a VM, where to get images, what a Dockerfile is, how to spin up a container, how to map ports & storage, and how to set up a little environment with multiple containers that communicate with one another (network). Next on my list for this one is: orchestration/k8s. </li>
    <li> <b> (improve) Software design for testability: </b> Are we ever really done with this one? :) Again, nothing really specific here, but I haven't stopped writing tests!</li> 
    <li> <b> API design: </b> Nope. </li> 
    <li> <b> Functions-as-a-Service: (probably AWS Lambda) </b> I did play with this one! See blog posts above. But nothing groundbreaking. </li>
  </ul> 

  <p> So I guess I've been working on less than I thought?! But I have been busy. At work I have the typical workload (+, you know, the pandemic).</p> 

<p> I've also been working on brushing up on SQL and concurrency. I apparently remember a lot about spin locks and not a lot else (probably beacuse I haven't done much of it outside of college OS class). </p>

  <h3> 1 March 2020 Lambdas! </h3> 
  <p> Today I was wandering around my little AWS playground and I was kind of bored by what I was doing (messing with flask and security groups) so I decided to see if I could get a Lambda up and running. Some days I love following tutorials and absorbing every word. Other days, I want to just break things and see how far I can get. Today was one of those days. </p>
  <p> So what is a Lambda? It's a function-as-a-service. You give AWS some code to run and it figures out the rest for you. How's that different from running code on EC2 or in a container? Well, it's even easier. There's no infrastructure, OS, or even runtime to worry about. You give AWS the code -- literally the source code -- and it takes care of the rest. </p>
  <p> Well you do have to give it a trigger. Otherwise it would just be code that AWS doesn't know when to run. </p> 
  <p> Here are (roughly) the steps with commentary, for doing what I did today: </p
  <ol>
    <li> In the AWS Console, open Lambdas and Create Function</li>
    <li> Author from scratch (it's more fun this way...?) </li>
    <li> Choose a runtime you like (Python here) </li>
    <li> Permissions: Create new with basic Lambda permissions </li>
    <li> Add trigger: API Gateway (trigger this function on an API call) </li> 
    <li> Create new REST API; Open with API Key </li> 
  </ol>

  <p> So at this point I ostensibly have my own API Gateway backed by a lambda function. But how do I use it? On the function's Configuration tab, there's a Designer diagram. Click the API Gateway icon. It will show some configurations, including the API endpoint. So open up a new tab and try it out! </p>
  <p> Well, you'll find that it doesn't work. You get a nice little {"message":"Forbidden"} response from your own API because you set the authorizations to Open with API Key but you didn't provide a key! </p>
  <p> Get the key from the AWS Console's API Gateway service and navigating to API Keys. The API Gateway page is also where you can disable API Keys or enable IAM authorizations for your APIs. </p>
  <p> One way to provide the API key to the endpoint is in the headers as an x-api-key. You'll notice that <code> curl $ApiEndpoint </code> gives you back the same forbidden response, while <code> curl -i -H "x-api-key: $Key" $Endpoint </code> invokes your Lambda! </p>
  <p> At this point your Lambda will execute the boilerplate Hello World python code that gets populated when you create a python Lambda but you can edit it to do whatever you want! </p>

  <h3> <b> 27 Feb 2020 </b> On Writing Good Unit Tests </h3>
  <p> I still remember the day I learned about automated testing. I was in my junior fall semester of college, taking a class about software engineering. All of my other classes up to that point had been very "CS"-y and not very, well, "practical." This particular class required a semester-long software engineering project with CI/CD, testing and (somewhat humorously) UML diagrams. A guest lecturer pulled my group to the side and asked us if we knew how to write a test. And thus the magic of Assert() was revealed to me. Today as a software engineer, I pride myself on the quality of my tests and the efficiency of my CI/CD pipeline. I don't consider a feature "done" unless there are tests. I will not tell you my code is "ready" if I didn't push the play button and wait for a versioned, tested executable to come out of the other end of the pipeline. I definitely think these are some of my strenghts as a software engineer but there are also some things that I'd still like to improve on in this area. </p> 

   <p> It's kind of hard to definitively say what a "good" test is but there are some easy ways to identify bad ones. So we can start there. Bad things to do in tests: </p>
   <ul>
    <li> Depend on other tests </li>
    <li> Depend on external factors that can change, such as databases or web services</li>
    <li> Only test the positive cases </li>
    <li> Stop writing tests after the initial development (if you find an edge case later, fix it and write a test!) </li> 
  </ul>

   <p> Here are my tips for good testing (but this is by no means comprehensive!): </p>
   <ul>
    <li> Think about equivalence classes & consider some (reasonable) ones </li
    <li> Fuzz it (aka throw absolute nonsense inputs at it). This one makes more sense if you have user-facing surfaces, but can be useful if you use a data source that could one day feed your program garbage. </li> 
    <li> Consider testing in your initial design (my current favorite framework for this is dependency injection) </li> 
    <li> Write a lot of small tests (hence the name "unit") but also consider some end-to-end tests to make sure your program executes in the way you think it does once it's all put together. I've caught some <b> nasty </b> bugs this way. </li> 
  </ul> 

  <p> Of course there are still things that mystify me about testing. Here are some of those things: </p>
  <ul>
    <li> Exactly which methods should I unit test? Only the external-facing ones? All of them? Even the tiny little helper classes? I tend to try to test every method, but am I doing this wrong? </li> 
    <li> Should I have some integration tests? How would I even achieve that? (I guess this one is pretty project-specific, but I still wonder.) </li>
  </ul>
    
  <p> In my personal experience, comprehensive unit testing has saved me a lot of trouble. It's costly to do up-front and your non-developer coworkers might question why simple features tend to take you so long, but you will more than make up for the time when your program works well and you can identify bugs very quickly. I <i>love</i> my end-to-end tests and I would hate to try to "verify" that my program was working by crawling through application logs and hoping everything looked right. When in doubt, write a test! Your future self will thank you. </p> 

       
  <h3> 5 Things I Want to Learn (or improve) in 2020 </h3>
  <ul>
    <li> Configuration management (probably Ansible) </li>
    <li> Containers </li>
    <li> (improve) Software design for testability </li> 
    <li> API design </li> 
    <li> Functions-as-a-Service (probably AWS Lambda) </li>
  </ul> 


<a href=index.html> back home </a>
</body>
</html>
